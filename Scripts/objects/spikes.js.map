{"version":3,"sources":["objects/spikes.ts"],"names":[],"mappings":";;;;;AAAA,IAAO,OAAO,CAkFb;AAlFD,WAAO,OAAO,EAAC,CAAC;IACZ,4DAA4D;IAC5D;QAA4B,0BAAkB;QAW1C,+CAA+C;QAC/C;YACI,kBAAM,QAAQ,CAAC,CAAC;YAEhB,MAAM,CAAC,SAAS,EAAE,CAAC;YACnB,0EAA0E;YAC1E,IAAI,CAAC,MAAM,EAAE,CAAC;YACd,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC;YACrB,IAAI,CAAC,CAAC,GAAI,aAAK,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,GAAE,CAAC,CAAC;YAEvC,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;YAClB,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC;YAExC,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;QACjC,CAAC;QAED,gDAAgD;QAChD,gEAAgE;QACtD,6BAAY,GAAtB,UAAuB,KAAa;YAIhC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC;gBAClB,IAAI,CAAC,MAAM,EAAE,CAAC;YAClB,CAAC;QACL,CAAC;QAED,4BAA4B;QAClB,uBAAM,GAAhB;YACI;qFACyE;YAEzE;;;;;;iGAMqF;YAErF,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;gBACrB,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC;YAC/B,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAA,CAAC;gBAC3B,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC;YAC5C,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,YAAY,GAAG,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,uBAAuB;YAC1E,CAAC;QAEL,CAAC,EAAA,SAAS;QAGV,gDAAgD;QAChD,qCAAqC;QAC9B,uBAAM,GAAb;YACI,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;gBACnB,IAAI,CAAC,MAAM,EAAE,CAAC;YAClB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBACpC,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YAC5B,CAAC,CAAA,MAAM;QACX,CAAC,EAAA,UAAU;QAlEJ,gBAAS,GAAW,CAAC,CAAC;QACtB,iBAAU,GAAY,KAAK,CAAC;QAC5B,iBAAU,GAAY,KAAK,CAAC;QAwEvC,aAAC;IAAD,CA/EA,AA+EC,CA/E2B,OAAO,CAAC,UAAU,GA+E7C;IA/EY,cAAM,SA+ElB,CAAA,CAAA,OAAO;AACZ,CAAC,EAlFM,OAAO,KAAP,OAAO,QAkFb,CAAA,QAAQ","file":"objects/spikes.js","sourcesContent":["module objects {\r\n    // Spikes (ENEMY) CLASS ++++++++++++++++++++++++++++++++++++\r\n    export class Spikes extends objects.GameObject {\r\n        // PRIVATE INSTANCE VARIABLES +++++++++++++++++\r\n        public isHittingPlayer: boolean;\r\n        public isHittingBat: boolean;\r\n        public projectileHit: boolean;\r\n        static numSpikes: number = 0;\r\n        static resetLock1: boolean = false;\r\n        static resetLock2: boolean = false;\r\n        \r\n        public isColliding: boolean;\r\n\r\n        // CONSTRUCTOR METHOD +++++++++++++++++++++++++\r\n        constructor() {\r\n            super(\"spikes\");\r\n\r\n            Spikes.numSpikes++;\r\n            //this._rightBounds += this._rightBounds + (Spikes.numSpikes * this.width)\r\n            this._reset();\r\n            this.name = \"spikes\";\r\n            this.y =  World.floor - this.height +3;  \r\n            \r\n            this._speed.x = 5;  \r\n            this._rightBounds = config.Screen.WIDTH;\r\n\r\n            this.isHittingPlayer = false;\r\n        }\r\n\r\n        // PRIVATE METHODS +++++++++++++++++++++++++++++\r\n        // check to see if the left of the enemy is outside the viewport\r\n        protected _checkBounds(value: number): void {\r\n            \r\n            \r\n            \r\n            if (this.x <= value) {\r\n                this._reset();\r\n            }\r\n        }\r\n\r\n        // reset the enemy offscreen\r\n        protected _reset(): void {\r\n            /*this._speed.y = Math.floor(Math.random() * 2) + 4; // between 4 and 6\r\n            this._speed.x = Math.floor(Math.random() * 10) - 5; // between -5 and 5*/\r\n            \r\n            /*since resets are unpredictable and objects are reset to similar the same y-value\r\n                an x position needs to be determined. Assuming 3 positions, 2 position locks have been made.\r\n                This sets a grid of 3 spaces [  ][  ][  ]\r\n                If an object exists in position 1, that position is locked until the last pixel of the image is \r\n                out of that space. Reset is done to the earliest available reset position available.\r\n                Checks for false condition for computational performance. \r\n                In future, for scalability, best to use array of locks based on # of instances.*/\r\n                       \r\n            if (!Spikes.resetLock1) { //check position 1\r\n                this.x = this._rightBounds;\r\n            } else if (!Spikes.resetLock2){ //position 1 occupied; check position 2...\r\n                this.x = this._rightBounds + this.width;\r\n            } else { //postition 2 occupied\r\n                this.x = this._rightBounds + (this.width * 2); //place in position 3. \r\n            }\r\n            \r\n        }//reset()\r\n\r\n\r\n        // PUBLIC METHODS ++++++++++++++++++++++++++++++\r\n        // scroll the enemy across the screen\r\n        public update(): void {\r\n            if (this.isColliding) {\r\n                this._reset();\r\n            } else {\r\n                this._checkBounds(this._leftBounds);\r\n                this.x -= this._speed.x;\r\n            }//else\r\n        }//update()\r\n        \r\n        /*\r\n        //reverse the horizontal motion of object (bounce)\r\n        public bounceX(): void {\r\n            this._speed.x = -this._speed.x;\r\n        }//bounceX\r\n        */\r\n    }//class\r\n}//module"],"sourceRoot":"/source/"}